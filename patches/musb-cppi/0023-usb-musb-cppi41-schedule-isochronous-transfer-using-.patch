From 73b9d0a152b8091d60d9f6a1774eb7c5b605a849 Mon Sep 17 00:00:00 2001
From: Ravi Babu <ravibabu@ti.com>
Date: Tue, 26 Mar 2013 14:07:55 +0530
Subject: [PATCH 23/30] usb: musb: cppi41: schedule isochronous transfer using sof interrupt

This fixes the txdma early completion issue for shortpkt
isochronous transfer. Indirectly this fixes audio gap issue in host
and the g_webcam gadget issue for short packet transfer.

Signed-off-by: Ravi Babu <ravibabu@ti.com>
---
 drivers/usb/musb/cppi41_dma.c  |  121 +++++++++++++++++++++++++++++++++++++++-
 drivers/usb/musb/cppi41_dma.h  |    2 +
 drivers/usb/musb/musb_core.h   |    1 +
 drivers/usb/musb/musb_dsps.c   |    5 +-
 drivers/usb/musb/musb_gadget.c |    9 ++-
 drivers/usb/musb/musb_host.c   |   17 ++++--
 6 files changed, 144 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 0ed6a19..bcc4c7a 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -47,6 +47,11 @@
  * Data structure definitions
  */
 
+#define USBREQ_DMA_INIT			0
+#define USBREQ_DMA_START		1
+#define USBREQ_DMA_INPROGRESS		2
+#define USBREQ_DMA_COMPLETE		3
+#define USBREQ_DMA_SHORTPKT_COMPLETE	4
 /*
  * USB Packet Descriptor
  */
@@ -101,10 +106,12 @@ struct cppi41_channel {
 	u8  tx_complete;
 	u8  rx_complete;
 	u8  hb_mult;
+	u8 xfer_state;
 	u32  count;
 	struct usb_pkt_desc *curr_pd;
 };
 
+
 /**
  * struct cppi41 - CPPI 4.1 DMA Controller Object
  *
@@ -132,6 +139,7 @@ struct cppi41 {
 	struct usb_cppi41_info *cppi_info; /* cppi channel information */
 	u32 bd_size;
 	u8  inf_mode;
+	u8  sof_isoc_started;
 };
 
 struct usb_cppi41_info usb_cppi41_info[2];
@@ -177,6 +185,21 @@ int get_xfer_type(struct musb_hw_ep *hw_ep, u8 is_tx)
 	u8 type = musb_readb(hw_ep->regs, is_tx ? MUSB_TXTYPE : MUSB_RXTYPE);
 	return (type >> 4) & 3;
 }
+
+static void musb_enable_tx_dma(struct musb_hw_ep *hw_ep)
+{
+	void __iomem *epio = hw_ep->regs;
+	u16 csr;
+
+	csr = musb_readw(epio, MUSB_TXCSR);
+	csr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_DMAMODE;
+	if (is_host_active(hw_ep->musb))
+		csr |= MUSB_TXCSR_H_WZC_BITS;
+	else
+		csr |= MUSB_TXCSR_MODE | MUSB_TXCSR_P_WZC_BITS;
+	musb_writew(epio, MUSB_TXCSR, csr);
+}
+
 /**
  * dma_controller_start - start DMA controller
  * @controller: the controller
@@ -614,6 +637,9 @@ static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
 	    tx_ch->ch_num, tx_ch->dma_mode ? "accelerated" : "transparent",
 	    pkt_size, num_pds, tx_ch->start_addr + tx_ch->curr_offset, length);
 
+	if (is_isoc)
+		tx_ch->xfer_state = USBREQ_DMA_INIT;
+
 	for (n = 0; n < num_pds; n++) {
 		struct cppi41_host_pkt_desc *hw_desc;
 
@@ -661,6 +687,16 @@ static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
 
 		cppi41_queue_push(&tx_ch->queue_obj, curr_pd->dma_addr,
 				  USB_CPPI41_DESC_ALIGN, pkt_size);
+
+		if (is_isoc && cppi_info->tx_isoc_sched_enab) {
+			tx_ch->xfer_state = USBREQ_DMA_START;
+			musb_enable_sof(cppi->musb);
+			if (cppi->sof_isoc_started) {
+				tx_ch->xfer_state = USBREQ_DMA_INPROGRESS;
+				musb_enable_tx_dma(tx_ch->end_pt);
+			}
+		}
+
 	}
 
 	return n;
@@ -1220,6 +1256,12 @@ static int cppi41_channel_abort(struct dma_channel *channel)
 	musb = cppi->musb;
 	dev = musb->controller;
 
+	if (cppi_info->tx_isoc_sched_enab &&
+		get_xfer_type(cppi_ch->end_pt, 1) == USB_ENDPOINT_XFER_ISOC) {
+		cppi_ch->xfer_state = USBREQ_DMA_INIT;
+		musb_disable_sof(musb);
+	}
+
 	switch (channel->status) {
 	case MUSB_DMA_STATUS_BUS_ABORT:
 	case MUSB_DMA_STATUS_CORE_ABORT:
@@ -1369,6 +1411,69 @@ static int cppi41_channel_abort(struct dma_channel *channel)
 	return 0;
 }
 
+int cppi41_isoc_schedular(struct musb *musb)
+{
+	struct cppi41 *cppi;
+	struct cppi41_channel *tx_ch;
+	struct usb_cppi41_info *cppi_info;
+	int index;
+
+	cppi = container_of(musb->dma_controller, struct cppi41, controller);
+	cppi_info = cppi->cppi_info;
+	for (index = 0; index < cppi_info->max_dma_ch; index++) {
+		void __iomem *epio;
+		u16 csr;
+
+		tx_ch = &cppi->tx_cppi_ch[index];
+
+		if (tx_ch->xfer_state == USBREQ_DMA_INIT ||
+			tx_ch->xfer_state == USBREQ_DMA_INPROGRESS)
+			continue;
+
+		epio = tx_ch->end_pt->regs;
+		csr = musb_readw(epio, MUSB_TXCSR);
+
+		switch (tx_ch->xfer_state) {
+
+		case USBREQ_DMA_SHORTPKT_COMPLETE:
+			if (cppi->sof_isoc_started) {
+				dev_dbg(musb->controller,
+				"Invalid state shortpkt complete occur ep%d\n",
+					index+1);
+				break;
+			}
+
+		case USBREQ_DMA_START:
+			if (tx_ch->xfer_state == USBREQ_DMA_SHORTPKT_COMPLETE)
+				tx_ch->xfer_state = USBREQ_DMA_COMPLETE;
+			else
+				tx_ch->xfer_state = USBREQ_DMA_INPROGRESS;
+
+			cppi->sof_isoc_started = 1;
+			musb_enable_tx_dma(tx_ch->end_pt);
+			dev_dbg(musb->controller, "isoc_sched: DMA_INP ep%d\n",
+					index+1);
+			break;
+
+		case USBREQ_DMA_COMPLETE:
+			tx_ch->channel.status = MUSB_DMA_STATUS_FREE;
+			tx_ch->xfer_state = USBREQ_DMA_INIT;
+			dev_dbg(musb->controller,
+				"isoc_sched: gvbk DMA_FREE  ep%d\n", index+1);
+			musb_dma_completion(cppi->musb, index+1, 1);
+			musb_disable_sof(cppi->musb);
+			break;
+
+		default:
+			dev_dbg(musb->controller,
+				"isoc_sched: invalid state%d ep%d\n",
+				tx_ch->xfer_state, index+1);
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_isoc_schedular);
+
 void txdma_completion_work(struct work_struct *data)
 {
 	struct cppi41 *cppi = container_of(data, struct cppi41, txdma_work);
@@ -1481,6 +1586,8 @@ struct dma_controller *dma_controller_create(struct musb  *musb,
 	cppi->cppi_info = (struct usb_cppi41_info *)&usb_cppi41_info[id];
 	INIT_WORK(&cppi->txdma_work, txdma_completion_work);
 	INIT_WORK(&cppi->rxdma_work, rxdma_completion_work);
+	if (musb->ops->sof_handler)
+		musb->tx_isoc_sched_enable = 1;
 
 	return &cppi->controller;
 err:
@@ -1525,7 +1632,7 @@ static void usb_process_tx_queue(struct cppi41 *cppi, unsigned index)
 	while ((pd_addr = cppi41_queue_pop(&tx_queue_obj)) != 0) {
 		struct usb_pkt_desc *curr_pd;
 		struct cppi41_channel *tx_ch;
-		u8 ch_num, ep_num;
+		u8 ch_num, ep_num, is_isoc;
 		u32 length;
 		u32 sched_work = 0;
 
@@ -1552,7 +1659,17 @@ static void usb_process_tx_queue(struct cppi41 *cppi, unsigned index)
 		 */
 		usb_put_free_pd(cppi, curr_pd);
 
-		if ((tx_ch->curr_offset < tx_ch->length) ||
+		is_isoc = get_xfer_type(tx_ch->end_pt, 1) ==
+				USB_ENDPOINT_XFER_ISOC;
+		if (is_isoc && cppi_info->tx_isoc_sched_enab) {
+			if (tx_ch->xfer_state == USBREQ_DMA_INPROGRESS)
+				tx_ch->xfer_state = USBREQ_DMA_COMPLETE;
+			else
+				tx_ch->xfer_state =
+					USBREQ_DMA_SHORTPKT_COMPLETE;
+			dev_dbg(musb->controller, "DMAIsr isoch: state %d ep%d len %d\n",
+					tx_ch->xfer_state, ep_num, length);
+		} else if ((tx_ch->curr_offset < tx_ch->length) ||
 		    (tx_ch->transfer_mode && !tx_ch->zlp_queued)) {
 			sched_work = 1;
 		} else if (tx_ch->channel.actual_len >= tx_ch->length) {
diff --git a/drivers/usb/musb/cppi41_dma.h b/drivers/usb/musb/cppi41_dma.h
index ff1b2c1..a5eaac9 100644
--- a/drivers/usb/musb/cppi41_dma.h
+++ b/drivers/usb/musb/cppi41_dma.h
@@ -101,6 +101,7 @@ struct usb_cppi41_info {
 	u8 bd_intr_enb;
 	u8 rx_dma_mode;
 	u8 rx_inf_mode;
+	u8 tx_isoc_sched_enab;
 	u8 sched_tbl_ctrl;
 	u32 version;
 	struct cppi41_wrapper_regs wrp;
@@ -115,4 +116,5 @@ extern struct usb_cppi41_info usb_cppi41_info[];
  * @tx:	bitmask having bit N set if Tx completion queue N is not empty
  */
 void cppi41_completion(struct musb *musb, u32 rx, u32 tx);
+int cppi41_isoc_schedular(struct musb *musb);
 #endif	/* _CPPI41_DMA_H_ */
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index a0d9b2d..598da7e 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -450,6 +450,7 @@ struct musb {
 	struct dentry		*debugfs_root;
 #endif
 	u32			sof_enabled;
+	u8			tx_isoc_sched_enable;
 };
 
 static inline struct musb *gadget_to_musb(struct usb_gadget *g)
diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index 23a1a45..43a6002 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -467,6 +467,7 @@ static int cppi41_init(struct dsps_glue *glue)
 		cppi_info->rx_dma_mode = USB_TRANSPARENT_MODE;
 		cppi_info->rx_inf_mode = 0;
 		cppi_info->sched_tbl_ctrl = 0;
+		cppi_info->tx_isoc_sched_enab = 1;
 
 		cppi_info->wrp.autoreq_reg = DSPS_USB_AUTOREQ_REG;
 		cppi_info->wrp.teardown_reg = DSPS_USB_TEARDOWN_REG;
@@ -1079,9 +1080,11 @@ static struct musb_platform_ops dsps_ops = {
 	.disable	= dsps_musb_disable,
 
 	.try_idle	= dsps_musb_try_idle,
-
 	.enable_sof	= dsps_enable_sof,
 	.disable_sof	= dsps_disable_sof,
+#ifdef CONFIG_USB_TI_CPPI41_DMA
+	.sof_handler	= cppi41_isoc_schedular,
+#endif
 };
 
 static u64 musb_dmamask = DMA_BIT_MASK(32);
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 3a553a3..0e62a8e 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -429,9 +429,12 @@ static void txstate(struct musb *musb, struct musb_request *req)
 
 			csr &= ~(MUSB_TXCSR_DMAMODE);
 			use_dma = 0;
-		} else
-			csr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_DMAMODE |
-				MUSB_TXCSR_MODE;
+		} else {
+			if (!musb->tx_isoc_sched_enable ||
+				musb_ep->type != USB_ENDPOINT_XFER_ISOC)
+				csr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_DMAMODE |
+					MUSB_TXCSR_MODE;
+		}
 
 		musb_writew(epio, MUSB_TXCSR,
 			(MUSB_TXCSR_P_WZC_BITS & ~MUSB_TXCSR_P_UNDERRUN)
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index d9659e6..46650b3 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -293,8 +293,11 @@ start:
 		if (!hw_ep->tx_channel)
 			musb_h_tx_start(hw_ep);
 		else if (is_cppi_enabled() || is_cppi41_enabled()
-				|| tusb_dma_omap())
-			musb_h_tx_dma_start(hw_ep);
+				|| tusb_dma_omap()) {
+			if (!musb->tx_isoc_sched_enable ||
+				qh->type != USB_ENDPOINT_XFER_ISOC)
+				musb_h_tx_dma_start(hw_ep);
+		}
 	}
 }
 
@@ -453,7 +456,8 @@ static u16 musb_h_flush_rxfifo(struct musb_hw_ep *hw_ep, u16 csr)
 	 * ignore dma (various models),
 	 * leave toggle alone (may not have been saved yet)
 	 */
-	csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;
+	if (csr & MUSB_RXCSR_RXPKTRDY)
+		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;
 	csr &= ~(MUSB_RXCSR_H_REQPKT
 		| MUSB_RXCSR_H_AUTOREQ
 		| MUSB_RXCSR_AUTOCLEAR);
@@ -1447,8 +1451,11 @@ done:
 		if (musb_tx_dma_program(musb->dma_controller, hw_ep, qh, urb,
 				offset, length)) {
 			if (is_cppi_enabled() || is_cppi41_enabled()
-				|| tusb_dma_omap())
-				musb_h_tx_dma_start(hw_ep);
+				|| tusb_dma_omap()) {
+				if (!musb->tx_isoc_sched_enable ||
+					qh->type != USB_ENDPOINT_XFER_ISOC)
+					musb_h_tx_dma_start(hw_ep);
+			}
 			return;
 		}
 	} else	if (tx_csr & MUSB_TXCSR_DMAENAB) {
-- 
1.7.0.4

