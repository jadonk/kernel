From c9675f11d2a358fc5760885c94611c34c60eaac3 Mon Sep 17 00:00:00 2001
From: Ravi Babu <ravibabu@ti.com>
Date: Sat, 16 Mar 2013 00:16:23 +0530
Subject: [PATCH 12/30] usb: musb: cppi41: Isochronous IN fixes for cppi4.1 DMA

- The isochronous IN URBs must be completed or giveback after
receiving all the isochronous frames, the cppi4.1 channel
must be programmed till all isoch frames are received.
- fixes the high bandwidth suppport for isochronous transfer
in dma mode.

Signed-off-by: Ravi Babu <ravibabu@ti.com>
---
 drivers/usb/musb/cppi41_dma.c |    2 +-
 drivers/usb/musb/musb_host.c  |   35 +++++++++++++++++++++++++----------
 2 files changed, 26 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 220d364..1f19ea5 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -959,7 +959,7 @@ static int cppi41_channel_program(struct dma_channel *channel,	u16 maxpacket,
 	cppi_ch->start_addr = dma_addr;
 	cppi_ch->curr_offset = 0;
 	cppi_ch->hb_mult = (maxpacket >> 11) & 0x03;
-	cppi_ch->pkt_size = maxpacket & 0x7ff;
+	cppi_ch->pkt_size = maxpacket & ~(3 << 11);
 	cppi_ch->length = length;
 	cppi_ch->transfer_mode = mode;
 	cppi_ch->zlp_queued = 0;
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 14937b7..0a1f222 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -666,7 +666,8 @@ static bool musb_tx_dma_program(struct dma_controller *dma,
 	 */
 	wmb();
 
-	if (!dma->channel_program(channel, pkt_size, mode,
+	if (!dma->channel_program(channel, pkt_size |
+			(qh->hb_mult << 11), mode,
 			urb->transfer_dma + offset, length)) {
 		dma->channel_release(channel);
 		hw_ep->tx_channel = NULL;
@@ -869,8 +870,8 @@ finish:
 		} else {
 			csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
 
-			if (csr & (MUSB_RXCSR_RXPKTRDY
-					| MUSB_RXCSR_DMAENAB
+			if (csr & (MUSB_RXCSR_RXPKTRDY |
+				(is_cppi41_enabled() ? 0 : MUSB_RXCSR_DMAENAB)
 					| MUSB_RXCSR_H_REQPKT))
 				ERR("broken !rx_reinit, ep%d csr %04x\n",
 						hw_ep->epnum, csr);
@@ -896,8 +897,9 @@ finish:
 			 * errors, we dare not queue multiple transfers.
 			 */
 			dma_ok = dma_controller->channel_program(dma_channel,
-					packet_sz, !(urb->transfer_flags &
-						     URB_SHORT_NOT_OK),
+					packet_sz | (qh->hb_mult << 11),
+					!(urb->transfer_flags &
+						URB_SHORT_NOT_OK),
 					urb->transfer_dma + offset,
 					qh->segsize);
 			if (!dma_ok) {
@@ -1673,9 +1675,13 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			| MUSB_RXCSR_H_AUTOREQ
 			| MUSB_RXCSR_AUTOCLEAR
 			| MUSB_RXCSR_RXPKTRDY);
+
+		if (is_cppi41_enabled() && usb_pipeisoc(pipe))
+			val |= MUSB_RXCSR_DMAENAB;
+
 		musb_writew(hw_ep->regs, MUSB_RXCSR, val);
 
-#ifdef CONFIG_USB_INVENTRA_DMA
+#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_TI_CPPI41_DMA)
 		if (usb_pipeisoc(pipe)) {
 			struct usb_iso_packet_descriptor *d;
 
@@ -1688,11 +1694,20 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			if (d->status != -EILSEQ && d->status != -EOVERFLOW)
 				d->status = 0;
 
+			done = false;
 			if (++qh->iso_idx >= urb->number_of_packets)
 				done = true;
-			else
-				done = false;
-
+			else if (is_cppi41_enabled()) {
+				struct dma_controller   *c;
+				int ret, idx = qh->iso_idx;
+
+				c = musb->dma_controller;
+				ret = c->channel_program(dma, qh->maxpacket |
+					(qh->hb_mult << 11), 0,
+					(u32)urb->transfer_dma +
+					urb->iso_frame_desc[idx].offset,
+					urb->iso_frame_desc[idx].length);
+			}
 		} else  {
 		/* done if urb buffer is full or short packet is recd */
 		done = (urb->actual_length + xfer_len >=
@@ -1835,7 +1850,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			 * adjusted first...
 			 */
 			ret = c->channel_program(
-				dma, qh->maxpacket,
+				dma, qh->maxpacket | ((qh->hb_mult - 1) << 11),
 				dma->desired_mode, buf, length);
 
 			if (!ret) {
-- 
1.7.0.4

