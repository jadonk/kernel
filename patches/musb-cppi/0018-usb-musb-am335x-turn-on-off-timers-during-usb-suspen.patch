From e6aaaf323c0219474a5bde96d0aeed08db14d233 Mon Sep 17 00:00:00 2001
From: Ravi Babu <ravibabu@ti.com>
Date: Wed, 27 Mar 2013 22:20:34 +0530
Subject: [PATCH 18/30] usb: musb: am335x: turn on/off timers during usb suspend/resume

There are two timers per musb port and they need to be
disabled (if active) before suspend and reenabled after resume.

Signed-off-by: Ravi Babu <ravibabu@ti.com>
---
 drivers/usb/musb/musb_core.h |    1 +
 drivers/usb/musb/musb_dsps.c |   32 +++++++++++++++++++++++++++++++-
 2 files changed, 32 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 9a40c23..de49ec2 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -336,6 +336,7 @@ struct musb {
 	struct list_head	out_bulk;	/* of musb_qh */
 
 	struct timer_list	otg_timer;
+	u8			en_otg_timer;
 	struct notifier_block	nb;
 
 	struct dma_controller	*dma_controller;
diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index aa80079..57e1a98 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -209,6 +209,7 @@ struct dsps_glue {
 	u32 __iomem *usb_ctrl[2];
 	u32 __iomem *usbss_addr;
 	u8	first;			/* ignore first call of resume */
+	u8	timer_enab[2];
 #ifdef CONFIG_PM
 	struct dsps_usbss_regs usbss_regs;
 	struct dsps_usb_regs usb_regs[2];
@@ -1318,8 +1319,22 @@ static void dsps_save_context(struct dsps_glue *glue)
 		struct dsps_usb_regs *usb = &glue->usb_regs[i];
 		const struct dsps_musb_wrapper *wrp = glue->wrp;
 		struct musb *musb = platform_get_drvdata(glue->musb[i]);
+		struct device *dev = musb->controller;
+		struct platform_device *pdev = to_platform_device(dev);
 		void __iomem *cbase = musb->ctrl_base;
 
+		/* disable the timers */
+		if (timer_pending(&glue->timer[pdev->id]) &&
+					is_host_active(musb)) {
+			del_timer_sync(&glue->timer[pdev->id]);
+			glue->timer_enab[pdev->id] = 1;
+		}
+
+		if (timer_pending(&musb->otg_timer)) {
+			del_timer_sync(&musb->otg_timer);
+			musb->en_otg_timer = 1;
+		}
+
 		musb_save_context(musb);
 		usb->control = musb_readl(cbase, wrp->control);
 
@@ -1357,7 +1372,7 @@ static void dsps_restore_context(struct dsps_glue *glue)
 	const struct dsps_musb_wrapper *wrp = glue->wrp;
 #ifdef CONFIG_USB_TI_CPPI41_DMA
 	void __iomem *usbss_addr = glue->usbss_addr;
-	struct dsps_usbss_wrapper *usbsswrp = &glue->wrp->usbss;
+	struct dsps_usbss_wrapper *usbsswrp;
 #endif
 	u8 i, j;
 
@@ -1366,6 +1381,7 @@ static void dsps_restore_context(struct dsps_glue *glue)
 			usbss->irq_en_set);
 
 #ifdef CONFIG_USB_TI_CPPI41_DMA
+	usbsswrp = (struct dsps_usbss_wrapper *)&wrp->usbss;
 	for (i = 0 ; i < 4 ; i++) {
 
 		dsps_writel(usbss_addr, usbsswrp->irq_tx0_dma_th_enb + (4 * i),
@@ -1399,6 +1415,8 @@ static void dsps_restore_context(struct dsps_glue *glue)
 		struct dsps_usb_regs *usb = &glue->usb_regs[i];
 		const struct dsps_musb_wrapper *wrp = glue->wrp;
 		struct musb *musb = platform_get_drvdata(glue->musb[i]);
+		struct device *dev = musb->controller;
+		struct platform_device *pdev = to_platform_device(dev);
 		void __iomem *cbase = musb->ctrl_base;
 
 		musb_restore_context(musb);
@@ -1425,6 +1443,18 @@ static void dsps_restore_context(struct dsps_glue *glue)
 		musb_writel(cbase, wrp->mgc_utmi_lpback,
 				usb->mgc_utmi_loopback);
 		musb_writel(cbase, wrp->mode, usb->mode);
+
+		/* reenable the timers */
+		if (glue->timer_enab[pdev->id] && is_host_active(musb)) {
+			mod_timer(&glue->timer[pdev->id],
+					jiffies + wrp->poll_seconds * HZ);
+			glue->timer_enab[pdev->id] = 0;
+		}
+		if (musb->en_otg_timer) {
+			mod_timer(&musb->otg_timer,
+					jiffies + wrp->poll_seconds * HZ);
+			musb->en_otg_timer = 0;
+		}
 	}
 	/* restore CPPI4.1 DMA register */
 #ifdef CONFIG_USB_TI_CPPI41_DMA
-- 
1.7.0.4

